The life cycle of any software consists of more than just its releases, and
the collection to the tools used to create it.
The architecture of the software, the languages used to write it, the
deployment mechanisms and the developer teams will change over time.
The only constant is change itself.
Traditional methods either fail in modeling the change, or are distributing
the change in a way that makes it very hard to track the change between
different level of abstractions.
This talk will present a unified process model that naturally spans from the
initial sketch of the software to the members of the classes.
Additionally, the model uses a well understood version control system in the
most natural way.
